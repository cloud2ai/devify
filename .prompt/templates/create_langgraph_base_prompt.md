# LangGraphÂü∫Á°ÄÁªÑ‰ª∂ÂàõÂª∫Ê†áÂáÜÊ®°Êùø

ËøôÊòØ‰∏Ä‰∏™ÈÄöÁî®ÁöÑLangGraphÂü∫Á°ÄÁªÑ‰ª∂ÂàõÂª∫ÊåáÂØºÊ®°ÊùøÔºåÈÄÇÁî®‰∫é‰ªª‰ΩïDjango + LangGraphÈ°πÁõÆ„ÄÇÂü∫‰∫éÊúÄ‰Ω≥ÂÆûË∑µÂíåÊàêÂäüÂÆûÁé∞ÁªèÈ™åÔºåÊèê‰æõÂÆåÊï¥ÁöÑÂü∫Á°ÄÁªÑ‰ª∂ÂºÄÂèëÊåáÂØº„ÄÇ

## üéØ ÈÄöÁî®ÈÖçÁΩÆËØ¥Êòé

### Âç†‰ΩçÁ¨¶ÊõøÊç¢ÊåáÂçó
Âú®‰ΩøÁî®Ê≠§Ê®°ÊùøÊó∂ÔºåËØ∑Â∞Ü‰ª•‰∏ãÂç†‰ΩçÁ¨¶ÊõøÊç¢‰∏∫ÂÆûÈôÖÂÄºÔºö

- `[ÂäüËÉΩ]` ‚Üí ÂÖ∑‰ΩìÂäüËÉΩÂêçÁß∞ÔºàÂ¶ÇÔºöspeech_to_text, email_processing, data_analysisÔºâ
- `[primary_id]` ‚Üí ‰∏ªË¶ÅÂÆû‰ΩìÁöÑIDÂèÇÊï∞ÂêçÔºàÂ¶ÇÔºöaudio_file_id, email_id, user_idÔºâ
- `[primary_entity]` ‚Üí ‰∏ªË¶ÅÂÆû‰ΩìÁöÑÂèòÈáèÂêçÔºàÂ¶ÇÔºöaudio_file, email, userÔºâ
- `[PrimaryEntity]` ‚Üí ‰∏ªË¶ÅÂÆû‰ΩìÁöÑÁ±ªÂêçÔºàÂ¶ÇÔºöAudioFile, Email, UserÔºâ
- `[YourModel]` ‚Üí ÂÆûÈôÖÁöÑÊï∞ÊçÆÊ®°ÂûãÁ±ªÂêç
- `[your_app]` ‚Üí ÂÆûÈôÖÁöÑDjangoÂ∫îÁî®ÂêçÁß∞
- `[StateName]` ‚Üí Áä∂ÊÄÅÁ±ªÂêçÔºàÂ¶ÇÔºöAudioFileState, EmailStateÔºâ
- `[node_name]` ‚Üí ËäÇÁÇπÂêçÁß∞ÔºàÂ¶ÇÔºöspeech_recognition_node, email_processing_nodeÔºâ

### È°πÁõÆÈÄÇÈÖçÊ£ÄÊü•Ê∏ÖÂçï
- [ ] Á°ÆËÆ§È°πÁõÆ‰ΩøÁî®Django + LangGraphÊû∂ÊûÑ
- [ ] Á°ÆËÆ§ÊúâÂêàÈÄÇÁöÑÊï∞ÊçÆÊ®°ÂûãÁî®‰∫éÁä∂ÊÄÅÁÆ°ÁêÜ
- [ ] Á°ÆËÆ§RedisÂ∑≤ÈÖçÁΩÆÁî®‰∫écheckpointÂ≠òÂÇ®
- [ ] Á°ÆËÆ§LangGraph‰æùËµñÂ∑≤ÂÆâË£Ö
- [ ] Á°ÆËÆ§Áä∂ÊÄÅÊûö‰∏æÂ∑≤ÂÆö‰πâ

## üìù ‰ª£Á†ÅÁîüÊàêËßÑËåÉ

**ÈáçË¶ÅÊèêÁ§∫**ÔºöËØ∑‰∏•Ê†ºÈÅµÂæ™È°πÁõÆ‰∏≠ÁöÑPython‰ª£Á†ÅËßÑËåÉÊ†áÂáÜ„ÄÇËØ¶ÁªÜËßÑËåÉËØ∑ÂèÇËÄÉÔºö`python_code_standards.md`

### ÂÖ≥ÈîÆË¶ÅÊ±ÇÊëòË¶Å
- ÊâÄÊúâ‰ª£Á†ÅÂíåÊ≥®ÈáäÂøÖÈ°ª‰ΩøÁî®Ëã±Êñá
- Á¶ÅÊ≠¢Ë°åÂÜÖÊ≥®ÈáäÔºåÊ≥®ÈáäÂøÖÈ°ªÂú®‰ª£Á†Å‰∏äÊñπ
- ÈÅµÂæ™PEP 8ËßÑËåÉÔºåÊØèË°å‰∏çË∂ÖËøá79Â≠óÁ¨¶
- ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂØºÂÖ•È°∫Â∫èÂíåÊñáÊ°£Â≠óÁ¨¶‰∏≤Ê†ºÂºè

## üèóÔ∏è Ê†∏ÂøÉÊû∂ÊûÑËÆæËÆ°ÂéüÂàô

### 1. StateÂÆö‰πâËÆæËÆ°Ê®°Âºè

#### [StateName] (TypedDict) ËÆæËÆ°
```python
"""
[ÂäüËÉΩ] State definitions for LangGraph workflow management.

This module defines the simplified state structure based on [PrimaryEntity] model,
focusing on storing results rather than complex workflow state management.
"""

from datetime import datetime
from typing import TypedDict, List, Dict, Any


class NodeError(TypedDict):
    """
    Error information for a specific node failure.
    """
    error_message: str
    timestamp: str


class [StateName](TypedDict, total=False):
    """
    Simplified state structure based on [PrimaryEntity] model.

    Focuses on storing results and processing data, excludes workflow
    execution fields. Uses segments array and counters for workflow control.
    """
    # Core [PrimaryEntity] fields (excluding status, timestamps, etc.)
    id: str
    user_id: str
    display_name: str | None
    file_size: int
    file_md5: str
    duration: float | None
    format: str
    storage_path: str | None
    storage_bucket: str | None
    sample_rate: int | None
    channels: int
    bit_rate: int | None
    asr_languages: List[str] | None
    llm_language: str | None
    scene: str | None

    # Processing results
    segments: List[Dict[str, Any]] | None
    segments_total_count: int | None

    # Final results
    summary: str | None
    translation: str | None

    # Workflow control
    force: bool
    node_errors: Dict[str, NodeError]


def add_node_error(
    state: [StateName],
    node_name: str,
    error_message: str
) -> [StateName]:
    """
    Add error information to the state for a specific node.

    Args:
        state: Current state
        node_name: Name of the node that encountered the error
        error_message: Error message to store

    Returns:
        Updated state with error information
    """
    if "node_errors" not in state:
        state["node_errors"] = {}

    state["node_errors"][node_name] = {
        "error_message": error_message,
        "timestamp": datetime.now().isoformat()
    }
    return state


def get_node_errors_by_name(
    state: [StateName],
    node_name: str
) -> List[NodeError]:
    """
    Get all errors for a specific node.

    Args:
        state: Current state
        node_name: Name of the node

    Returns:
        List of errors for the node
    """
    if "node_errors" not in state:
        return []

    node_errors = state["node_errors"].get(node_name, [])
    if isinstance(node_errors, list):
        return node_errors
    return [node_errors] if node_errors else []


def has_node_errors(state: [StateName]) -> bool:
    """
    Check if there are any node errors in the state.

    Args:
        state: Current state

    Returns:
        True if there are errors, False otherwise
    """
    return bool(state.get("node_errors"))
```

### 2. BaseLangGraphNodeËÆæËÆ°Ê®°Âºè

#### Âü∫Á°ÄËäÇÁÇπÁ±ªËÆæËÆ°
```python
"""
Base LangGraph Node implementation.

This module provides the base class for all LangGraph nodes in the
[ÂäüËÉΩ] workflow, ensuring consistent structure, error handling,
and logging.
"""

import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

from [your_app].agents.[ÂäüËÉΩ]_state import (
    [StateName],
    add_node_error,
    get_node_errors_by_name,
    has_node_errors
)

logger = logging.getLogger(__name__)


class BaseLangGraphNode(ABC):
    """
    Base class for all LangGraph nodes in the [ÂäüËÉΩ] workflow.

    This class provides a standardized structure for LangGraph nodes with:
    - Three-phase processing: before_processing, execute_processing, after_processing
    - Consistent error handling and logging based on node_errors
    - Automatic node entry validation based on error states

    Subclasses can implement:
    - before_processing(): Pre-processing validation and setup
    - execute_processing(): Core business logic (required)
    - after_processing(): Post-processing cleanup and finalization
    """

    def __init__(self, node_name: str):
        """
        Initialize the base node.

        Args:
            node_name (str): Name of the node for logging and identification
        """
        self.node_name = node_name
        self.logger = logging.getLogger(f"[{node_name}]")

    def __call__(self, state: [StateName]) -> [StateName]:
        """
        LangGraph Node standard call interface.

        This method orchestrates the three-phase processing:
        1. before_processing: Validation and setup
        2. execute_processing: Core business logic
        3. after_processing: Cleanup and finalization

        Args:
            state: Current workflow state

        Returns:
            Updated state after processing
        """
        try:
            self.logger.info(f"Starting {self.node_name} processing")

            # Phase 1: Pre-processing validation and setup
            state = self.before_processing(state)

            # Phase 2: Core business logic
            state = self.execute_processing(state)

            # Phase 3: Post-processing cleanup and finalization
            state = self.after_processing(state)

            self.logger.info(f"Completed {self.node_name} processing")
            return state

        except Exception as e:
            self.logger.error(f"Error in {self.node_name}: {str(e)}")
            state = add_node_error(state, self.node_name, str(e))
            return state

    def before_processing(self, state: [StateName]) -> [StateName]:
        """
        Pre-processing validation and setup.

        This method is called before execute_processing and should:
        - Validate input state
        - Check for required dependencies
        - Perform any necessary setup

        Args:
            state: Current workflow state

        Returns:
            Updated state after pre-processing
        """
        # Check if there are any previous errors
        if has_node_errors(state):
            self.logger.warning(f"Skipping {self.node_name} due to previous errors")
            return state

        # Check if already completed (for idempotency)
        if self.is_already_completed(state):
            self.logger.info(f"{self.node_name} already completed, skipping")
            return state

        return state

    @abstractmethod
    def execute_processing(self, state: [StateName]) -> [StateName]:
        """
        Core business logic processing.

        This method must be implemented by subclasses and should contain
        the main processing logic for the node.

        Args:
            state: Current workflow state

        Returns:
            Updated state after processing
        """
        pass

    def after_processing(self, state: [StateName]) -> [StateName]:
        """
        Post-processing cleanup and finalization.

        This method is called after execute_processing and should:
        - Clean up any temporary resources
        - Perform any necessary finalization
        - Update state with results

        Args:
            state: Current workflow state

        Returns:
            Updated state after post-processing
        """
        return state

    def is_already_completed(self, state: [StateName]) -> bool:
        """
        Check if the node has already completed its processing.

        This method should be overridden by subclasses to implement
        their specific completion logic.

        Args:
            state: Current workflow state

        Returns:
            True if already completed, False otherwise
        """
        return False
```

### 3. CheckpointManagerËÆæËÆ°Ê®°Âºè

#### Redis CheckpointÁÆ°ÁêÜ
```python
"""
Redis Checkpoint Manager for LangGraph workflows.

This module provides checkpoint management functionality for LangGraph
workflows using Redis as the storage backend.
"""

import logging
from typing import Optional, Dict, Any

from langgraph.checkpoint.redis import RedisSaver
from django.conf import settings

logger = logging.getLogger(__name__)


class CheckpointManager:
    """
    Manages Redis checkpoints for LangGraph workflows.

    This class provides a centralized way to create and manage
    Redis checkpoints for LangGraph workflows.
    """

    def __init__(self):
        """
        Initialize the checkpoint manager.
        """
        self.redis_url = getattr(settings, 'REDIS_URL', 'redis://localhost:6379')
        self.checkpointer = None

    def get_checkpointer(self) -> RedisSaver:
        """
        Get or create a Redis checkpointer.

        Returns:
            RedisSaver instance for checkpoint management
        """
        if self.checkpointer is None:
            try:
                self.checkpointer = RedisSaver.from_url(self.redis_url)
                logger.info("Redis checkpointer initialized successfully")
            except Exception as e:
                logger.error(f"Failed to initialize Redis checkpointer: {e}")
                raise

        return self.checkpointer

    def create_checkpoint_config(self) -> Dict[str, Any]:
        """
        Create checkpoint configuration for LangGraph workflows.

        Returns:
            Dictionary containing checkpoint configuration
        """
        return {
            "checkpointer": self.get_checkpointer(),
            "checkpoint_id": "workflow_checkpoint"
        }


# Global checkpoint manager instance
checkpoint_manager = CheckpointManager()


def create_checkpointer() -> RedisSaver:
    """
    Create a Redis checkpointer instance.

    This function provides a convenient way to create checkpointer
    instances for LangGraph workflows.

    Returns:
        RedisSaver instance
    """
    return checkpoint_manager.get_checkpointer()
```

## üîÑ Áä∂ÊÄÅÁÆ°ÁêÜËÆæËÆ°ÂéüÂàô

### 1. Áä∂ÊÄÅÁªìÊûÑËÆæËÆ°

**Ê†∏ÂøÉÂéüÂàô**Ôºö
- Áõ¥Êé•Êò†Â∞ÑÊï∞ÊçÆÂ∫ìÊ®°ÂûãÂ≠óÊÆµÔºåÊñπ‰æøÊï∞ÊçÆÂä†ËΩΩÂíåÂ≠òÂÇ®
- ÂåÖÂê´Â§ÑÁêÜÁªìÊûúÂ≠óÊÆµÔºösegments„ÄÅsummaryÁ≠â
- ÂåÖÂê´Â∑•‰ΩúÊµÅÊéßÂà∂Â≠óÊÆµÔºöforce„ÄÅnode_errorsÁ≠â
- ÈÅøÂÖçËøáÂ∫¶ÈÄöÁî®ÂåñÔºåÊåâÂÆûÈôÖÈúÄÊ±ÇËÆæËÆ°

**Áä∂ÊÄÅÂ≠óÊÆµÂàÜÁ±ª**Ôºö
```python
# Ê†∏ÂøÉÂÆû‰ΩìÂ≠óÊÆµ
id: str
user_id: str
display_name: str | None
# ... ÂÖ∂‰ªñÊ®°ÂûãÂ≠óÊÆµ

# Â§ÑÁêÜÁªìÊûúÂ≠óÊÆµ
segments: List[Dict[str, Any]] | None
summary: str | None
# ... ÂÖ∂‰ªñÁªìÊûúÂ≠óÊÆµ

# Â∑•‰ΩúÊµÅÊéßÂà∂Â≠óÊÆµ
force: bool
node_errors: Dict[str, NodeError]
```

### 2. ÈîôËØØÂ§ÑÁêÜËÆæËÆ°

**ÈîôËØØ‰ø°ÊÅØÁªìÊûÑ**Ôºö
```python
class NodeError(TypedDict):
    error_message: str
    timestamp: str
```

**ÈîôËØØÁÆ°ÁêÜÂáΩÊï∞**Ôºö
- `add_node_error()`: Ê∑ªÂä†ËäÇÁÇπÈîôËØØ
- `get_node_errors_by_name()`: Ëé∑ÂèñÁâπÂÆöËäÇÁÇπÈîôËØØ
- `has_node_errors()`: Ê£ÄÊü•ÊòØÂê¶ÊúâÈîôËØØ

### 3. ËäÇÁÇπÂü∫Á±ªËÆæËÆ°

**‰∏âÈò∂ÊÆµÂ§ÑÁêÜÊ®°Âºè**Ôºö
1. **before_processing()**: È¢ÑÂ§ÑÁêÜÈ™åËØÅÂíåËÆæÁΩÆ
2. **execute_processing()**: Ê†∏ÂøÉ‰∏öÂä°ÈÄªËæëÔºàÂøÖÈ°ªÂÆûÁé∞Ôºâ
3. **after_processing()**: ÂêéÂ§ÑÁêÜÊ∏ÖÁêÜÂíåÂÆåÊàê

**ÂÖ≥ÈîÆÁâπÊÄß**Ôºö
- Áªü‰∏ÄÁöÑÈîôËØØÂ§ÑÁêÜÂíåÊó•ÂøóËÆ∞ÂΩï
- Âü∫‰∫énode_errorsÁöÑËá™Âä®ËäÇÁÇπÂÖ•Âè£È™åËØÅ
- ÊîØÊåÅÂπÇÁ≠âÊÄßÊ£ÄÊü•
- Ê†áÂáÜÂåñÁöÑLangGraphËäÇÁÇπÊé•Âè£

## üìù Êó•ÂøóËæìÂá∫Ê†áÂáÜÂåñ

### 1. Áªü‰∏ÄÊó•ÂøóÊ†áÁ≠æ
```python
# ‰ΩøÁî®ËäÇÁÇπÂêçÁß∞‰Ωú‰∏∫Êó•ÂøóÊ†áÁ≠æ
self.logger = logging.getLogger(f"[{node_name}]")

# Êó•ÂøóËæìÂá∫Á§∫‰æã
self.logger.info(f"Starting {self.node_name} processing")
self.logger.info(f"Completed {self.node_name} processing")
self.logger.error(f"Error in {self.node_name}: {str(e)}")
```

### 2. Ë°åÈïøÂ∫¶ÊéßÂà∂Ôºà‚â§79Â≠óÁ¨¶Ôºâ
```python
# Ê≠£Á°ÆÁöÑÂàÜË°åÊñπÂºè
self.logger.info(f"Starting {self.node_name} processing")

# Âú®ÈÄªËæëÊñ≠ÁÇπÂ§ÑÂàÜË°åÔºå‰øùÊåÅËØ≠‰πâÂÆåÊï¥
self.logger.error(f"Error in {self.node_name}: {str(e)}")
```

### 3. Êó•ÂøóÁ∫ßÂà´‰ΩøÁî®
- **info**: Ê≠£Â∏∏ÊµÅÁ®ãËäÇÁÇπÂíåÈáçË¶ÅÁä∂ÊÄÅÂèòÂåñ
- **warning**: Ë∑≥ËøáÂ§ÑÁêÜÁöÑÊÉÖÂÜµ
- **error**: ÈîôËØØÊÉÖÂÜµÂíåÂºÇÂ∏∏Â§ÑÁêÜ

## üîß Âü∫Á°ÄÁªÑ‰ª∂ÊûÑÂª∫ÊúÄ‰Ω≥ÂÆûË∑µ

### 1. StateÂÆö‰πâÊúÄ‰Ω≥ÂÆûË∑µ
```python
# ÊåâÊï∞ÊçÆÂ∫ìÊ®°ÂûãÊäΩË±°ÔºåÈÅøÂÖçËøáÂ∫¶ÈÄöÁî®Âåñ
class [StateName](TypedDict, total=False):
    # Áõ¥Êé•Êò†Â∞ÑÊ®°ÂûãÂ≠óÊÆµ
    id: str
    user_id: str
    # ... ÂÖ∂‰ªñÂ≠óÊÆµ

# ÂåÖÂê´Â§ÑÁêÜÁªìÊûúÂ≠óÊÆµ
segments: List[Dict[str, Any]] | None
summary: str | None

# ÂåÖÂê´Â∑•‰ΩúÊµÅÊéßÂà∂Â≠óÊÆµ
force: bool
node_errors: Dict[str, NodeError]
```

### 2. ËäÇÁÇπÂü∫Á±ªÊúÄ‰Ω≥ÂÆûË∑µ
```python
# ‰∏âÈò∂ÊÆµÂ§ÑÁêÜÊ®°Âºè
def __call__(self, state: [StateName]) -> [StateName]:
    try:
        # Phase 1: Pre-processing
        state = self.before_processing(state)

        # Phase 2: Core business logic
        state = self.execute_processing(state)

        # Phase 3: Post-processing
        state = self.after_processing(state)

        return state
    except Exception as e:
        # Áªü‰∏ÄÈîôËØØÂ§ÑÁêÜ
        state = add_node_error(state, self.node_name, str(e))
        return state
```

### 3. CheckpointÁÆ°ÁêÜÊúÄ‰Ω≥ÂÆûË∑µ
```python
# ‰ΩøÁî®Âçï‰æãÊ®°ÂºèÁÆ°ÁêÜcheckpointer
checkpoint_manager = CheckpointManager()

# Êèê‰æõ‰æøÊç∑ÁöÑÂàõÂª∫ÂáΩÊï∞
def create_checkpointer() -> RedisSaver:
    return checkpoint_manager.get_checkpointer()
```

## üõ°Ô∏è ÈîôËØØÂ§ÑÁêÜÊ®°Âºè

### 1. ËäÇÁÇπÈîôËØØÂ§ÑÁêÜ
```python
def __call__(self, state: [StateName]) -> [StateName]:
    try:
        # Â§ÑÁêÜÈÄªËæë
        pass
    except Exception as e:
        self.logger.error(f"Error in {self.node_name}: {str(e)}")
        state = add_node_error(state, self.node_name, str(e))
        return state
```

### 2. Áä∂ÊÄÅÈ™åËØÅ
```python
def before_processing(self, state: [StateName]) -> [StateName]:
    # Ê£ÄÊü•ÊòØÂê¶Êúâ‰πãÂâçÁöÑÈîôËØØ
    if has_node_errors(state):
        self.logger.warning(f"Skipping {self.node_name} due to previous errors")
        return state

    # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÂÆåÊàê
    if self.is_already_completed(state):
        self.logger.info(f"{self.node_name} already completed, skipping")
        return state

    return state
```

### 3. CheckpointÈîôËØØÂ§ÑÁêÜ
```python
def get_checkpointer(self) -> RedisSaver:
    if self.checkpointer is None:
        try:
            self.checkpointer = RedisSaver.from_url(self.redis_url)
            logger.info("Redis checkpointer initialized successfully")
        except Exception as e:
            logger.error(f"Failed to initialize Redis checkpointer: {e}")
            raise

    return self.checkpointer
```

## üìä Ë∞ÉËØïÂíåÁõëÊéßÊîØÊåÅ

### 1. Áä∂ÊÄÅË∞ÉËØï
```python
# ËÆ∞ÂΩïÁä∂ÊÄÅ‰ø°ÊÅØ
self.logger.debug(f"Current state: {state}")

# ËÆ∞ÂΩïÂ§ÑÁêÜÁªìÊûú
self.logger.info(f"Processing completed for {self.node_name}")
```

### 2. ÈîôËØØÁõëÊéß
```python
# ËÆ∞ÂΩïÈîôËØØ‰ø°ÊÅØ
self.logger.error(f"Error in {self.node_name}: {str(e)}")

# ËÆ∞ÂΩïË∑≥ËøáÂéüÂõ†
self.logger.warning(f"Skipping {self.node_name} due to previous errors")
```

## üìã ÂÖ∑‰ΩìÂÆûÁé∞Ê£ÄÊü•Ê∏ÖÂçï

### ‚úÖ ÂøÖÈ°ªÂÆûÁé∞ÁöÑÁªìÊûÑ
- [ ] Ê≠£Á°ÆÁöÑStateÂÆö‰πâÔºàTypedDictÔºâ
- [ ] Ê≠£Á°ÆÁöÑNodeErrorÂÆö‰πâ
- [ ] ÂÆåÊï¥ÁöÑÈîôËØØÁÆ°ÁêÜÂáΩÊï∞
- [ ] Ê≠£Á°ÆÁöÑBaseLangGraphNodeÂü∫Á±ª
- [ ] Ê≠£Á°ÆÁöÑCheckpointManagerÁ±ª
- [ ] ÂÆåÊï¥ÁöÑÊñáÊ°£Â≠óÁ¨¶‰∏≤

### ‚úÖ StateÂÆö‰πâÊ£ÄÊü•
- [ ] Áõ¥Êé•Êò†Â∞ÑÊï∞ÊçÆÂ∫ìÊ®°ÂûãÂ≠óÊÆµ
- [ ] ÂåÖÂê´Â§ÑÁêÜÁªìÊûúÂ≠óÊÆµ
- [ ] ÂåÖÂê´Â∑•‰ΩúÊµÅÊéßÂà∂Â≠óÊÆµ
- [ ] ‰ΩøÁî®Ê≠£Á°ÆÁöÑÁ±ªÂûãÊ≥®Ëß£
- [ ] ÈÅøÂÖçËøáÂ∫¶ÈÄöÁî®Âåñ

### ‚úÖ ËäÇÁÇπÂü∫Á±ªÊ£ÄÊü•
- [ ] ‰∏âÈò∂ÊÆµÂ§ÑÁêÜÊ®°Âºè
- [ ] Áªü‰∏ÄÁöÑÈîôËØØÂ§ÑÁêÜ
- [ ] Ê≠£Á°ÆÁöÑÊó•ÂøóËÆ∞ÂΩï
- [ ] ÊîØÊåÅÂπÇÁ≠âÊÄßÊ£ÄÊü•
- [ ] Ê†áÂáÜÂåñÁöÑÊé•Âè£

### ‚úÖ CheckpointÁÆ°ÁêÜÊ£ÄÊü•
- [ ] Ê≠£Á°ÆÁöÑRedisÈÖçÁΩÆ
- [ ] Âçï‰æãÊ®°ÂºèÂÆûÁé∞
- [ ] ÈîôËØØÂ§ÑÁêÜÊú∫Âà∂
- [ ] ‰æøÊç∑ÁöÑÂàõÂª∫ÂáΩÊï∞

### ‚úÖ ‰ª£Á†ÅËßÑËåÉÊ£ÄÊü•
- [ ] ÊâÄÊúâ‰ª£Á†Å‰ΩøÁî®Ëã±Êñá
- [ ] ÊâÄÊúâÊ≥®Èáä‰ΩøÁî®Ëã±Êñá
- [ ] Á¶ÅÊ≠¢Ë°åÂÜÖÊ≥®Èáä
- [ ] ÈÅµÂæ™PEP 8ËßÑËåÉ
- [ ] ÊØèË°å‰∏çË∂ÖËøá79Â≠óÁ¨¶

## üéØ ÂÖ≥ÈîÆÂÆûÁé∞ÁªÜËäÇ

### 1. StateËÆæËÆ°Ê®°Âºè
```python
# ÊåâÊï∞ÊçÆÂ∫ìÊ®°ÂûãÊäΩË±°ÔºåÈÅøÂÖçËøáÂ∫¶ÈÄöÁî®Âåñ
class [StateName](TypedDict, total=False):
    # Ê†∏ÂøÉÂ≠óÊÆµ
    id: str
    user_id: str
    # Â§ÑÁêÜÁªìÊûú
    segments: List[Dict[str, Any]] | None
    summary: str | None
    # Â∑•‰ΩúÊµÅÊéßÂà∂
    force: bool
    node_errors: Dict[str, NodeError]
```

### 2. ËäÇÁÇπÂü∫Á±ªÊ®°Âºè
```python
# ‰∏âÈò∂ÊÆµÂ§ÑÁêÜÊ®°Âºè
def __call__(self, state: [StateName]) -> [StateName]:
    try:
        state = self.before_processing(state)
        state = self.execute_processing(state)
        state = self.after_processing(state)
        return state
    except Exception as e:
        state = add_node_error(state, self.node_name, str(e))
        return state
```

### 3. CheckpointÁÆ°ÁêÜÊ®°Âºè
```python
# Âçï‰æãÊ®°ÂºèÁÆ°ÁêÜcheckpointer
class CheckpointManager:
    def __init__(self):
        self.checkpointer = None

    def get_checkpointer(self) -> RedisSaver:
        if self.checkpointer is None:
            self.checkpointer = RedisSaver.from_url(self.redis_url)
        return self.checkpointer
```

## üö® Â∏∏ËßÅÈô∑Èò±ÂíåÈÅøÂÖçÊñπÊ≥ï

### ‚ùå ÈÅøÂÖçÁöÑÂèçÊ®°Âºè
1. **ËøáÂ∫¶ÈÄöÁî®ÂåñÁöÑState** - Â∫îËØ•ÊåâÊï∞ÊçÆÂ∫ìÊ®°ÂûãÊäΩË±°
2. **Áº∫Â∞ëÈîôËØØÂ§ÑÁêÜ** - Â∫îËØ•Áªü‰∏ÄÂ§ÑÁêÜÂºÇÂ∏∏
3. **Á°¨ÁºñÁ†ÅÊó•ÂøóÊ†áÁ≠æ** - Â∫îËØ•‰ΩøÁî®ËäÇÁÇπÂêçÁß∞
4. **Áº∫Â∞ëÂπÇÁ≠âÊÄßÊ£ÄÊü•** - Â∫îËØ•ÊîØÊåÅÈáçÂ§çÊâßË°å
5. **‰ΩøÁî®Ë°åÂÜÖÊ≥®Èáä** - Â∫îËØ•Â∞ÜÊ≥®ÈáäÊîæÂú®‰ª£Á†Å‰∏äÊñπ
6. **‰ΩøÁî®‰∏≠ÊñáÊ≥®Èáä** - ÊâÄÊúâÊ≥®ÈáäÂøÖÈ°ª‰ΩøÁî®Ëã±Êñá

### ‚úÖ Êé®ËçêÁöÑÊúÄ‰Ω≥ÂÆûË∑µ
1. **ÊåâÊ®°ÂûãÊäΩË±°State** - ÈÅøÂÖçËøáÂ∫¶ÈÄöÁî®Âåñ
2. **‰∏âÈò∂ÊÆµÂ§ÑÁêÜÊ®°Âºè** - Á°Æ‰øùÂ§ÑÁêÜÈÄªËæëÊ∏ÖÊô∞
3. **Áªü‰∏ÄÁöÑÈîôËØØÂ§ÑÁêÜ** - Á°Æ‰øùÂºÇÂ∏∏Ê≠£Á°Æ‰º†Êí≠
4. **ÂÆåÊï¥ÁöÑÊñáÊ°£Â≠óÁ¨¶‰∏≤** - ‰æø‰∫éÁêÜËß£ÂíåÁª¥Êä§
5. **Ëã±Êñá‰ª£Á†ÅÂíåÊ≥®Èáä** - ‰øùÊåÅ‰ª£Á†ÅÂõΩÈôÖÂåñ
6. **ÈÅµÂæ™PEP 8ËßÑËåÉ** - ‰øùÊåÅ‰ª£Á†Å‰∏ÄËá¥ÊÄß

## üìù ‰ΩøÁî®ÊåáÂçó

### Âø´ÈÄüÂºÄÂßã
1. **Â§çÂà∂Ê≠§Ê®°Êùø**‰Ωú‰∏∫Âü∫Á°ÄÁªÑ‰ª∂ÁöÑËµ∑ÂßãÁÇπ
2. **ÊõøÊç¢Âç†‰ΩçÁ¨¶**ÔºöÊ†πÊçÆÂç†‰ΩçÁ¨¶ÊõøÊç¢ÊåáÂçóÊõ¥Êñ∞ÊâÄÊúâÂç†‰ΩçÁ¨¶
3. **Ë∞ÉÊï¥StateÂÆö‰πâ**ÔºöÊ†πÊçÆÂÆûÈôÖÊï∞ÊçÆÊ®°Âûã‰øÆÊîπStateÁªìÊûÑ
4. **ÂÆûÁé∞ËäÇÁÇπÂü∫Á±ª**ÔºöÊ†πÊçÆÂÖ∑‰ΩìÈúÄÊ±ÇÂÆûÁé∞BaseLangGraphNode
5. **ÈÖçÁΩÆCheckpoint**ÔºöÊ†πÊçÆRedisÈÖçÁΩÆË∞ÉÊï¥CheckpointManager
6. **ÊµãËØïÂü∫Á°ÄÁªÑ‰ª∂**ÔºöÁ°Æ‰øùState„ÄÅBaseNode„ÄÅCheckpointÊ≠£Â∏∏Â∑•‰Ωú

### Â∏∏ËßÅ‰ΩøÁî®Âú∫ÊôØ
- **ËØ≠Èü≥Â§ÑÁêÜÂ∑•‰ΩúÊµÅ**ÔºöAudioFileState + ËØ≠Èü≥ËØÜÂà´ËäÇÁÇπ
- **ÈÇÆ‰ª∂Â§ÑÁêÜÂ∑•‰ΩúÊµÅ**ÔºöEmailState + ÈÇÆ‰ª∂ÂàÜÊûêËäÇÁÇπ
- **Êï∞ÊçÆÂàÜÊûêÂ∑•‰ΩúÊµÅ**ÔºöDataState + Êï∞ÊçÆÂ§ÑÁêÜËäÇÁÇπ
- **Êñá‰ª∂Â§ÑÁêÜÂ∑•‰ΩúÊµÅ**ÔºöFileState + Êñá‰ª∂ËΩ¨Êç¢ËäÇÁÇπ

### È´òÁ∫ßÈÖçÁΩÆÈÄâÈ°π
- **Ëá™ÂÆö‰πâStateÂ≠óÊÆµ**ÔºöÊ†πÊçÆ‰∏öÂä°ÈúÄÊ±ÇÊ∑ªÂä†ÁâπÂÆöÂ≠óÊÆµ
- **Ëá™ÂÆö‰πâÈîôËØØÂ§ÑÁêÜ**ÔºöÂÆûÁé∞ÁâπÂÆöÁöÑÈîôËØØÂ§ÑÁêÜÈÄªËæë
- **Ëá™ÂÆö‰πâCheckpointÈÖçÁΩÆ**ÔºöÈÖçÁΩÆÁâπÂÆöÁöÑRedisÂèÇÊï∞
- **ÊÄßËÉΩ‰ºòÂåñ**Ôºö‰ΩøÁî®ÁºìÂ≠òÂíåÊâπÈáèÊìç‰Ωú‰ºòÂåñÊÄßËÉΩ

Ëøô‰∏™Ê®°ÊùøÂü∫‰∫éLangGraphÊúÄ‰Ω≥ÂÆûË∑µÂíåÊàêÂäüÂÆûÁé∞ÁªèÈ™åÔºåÂåÖÂê´‰∫ÜÊâÄÊúâÂÖ≥ÈîÆÁöÑÂü∫Á°ÄÁªÑ‰ª∂ËÆæËÆ°Ê®°ÂºèÂíåÂÆûÁé∞ÁªÜËäÇÔºåÈÄÇÁî®‰∫é‰ªª‰ΩïDjango + LangGraphÈ°πÁõÆ„ÄÇ
