"""
EmailState definitions for email processing workflow management.

This module defines the state structure based on EmailMessage model,
focusing on storing results and workflow processing data.
"""

from datetime import datetime
from typing import TypedDict, List, Dict, Any


class NodeError(TypedDict):
    """
    Error information for a specific node failure.
    """
    error_message: str
    timestamp: str


class EmailAttachmentState(TypedDict, total=False):
    """
    Attachment information within email state.
    """
    id: str
    filename: str
    safe_filename: str
    content_type: str
    file_size: int
    file_path: str
    is_image: bool
    ocr_content: str | None
    llm_content: str | None


class EmailState(TypedDict, total=False):
    """
    State structure for email processing workflow.

    Three categories of fields:
    1. Core fields: Mapped from EmailMessage and EmailTask models
    2. Result fields: Generated by workflow processing
    3. Fixed fields: Common control and error tracking fields
    """
    # Core EmailMessage fields
    id: str
    user_id: str
    message_id: str
    subject: str
    sender: str
    recipients: str
    received_at: str
    raw_content: str
    html_content: str
    text_content: str

    # Attachment information
    attachments: List[EmailAttachmentState] | None

    # Processing result fields
    summary_title: str | None
    summary_content: str | None
    llm_content: str | None
    metadata: Dict[str, Any] | None

    # Issue creation results (core fields - engine agnostic)
    issue_id: int | None              # Database Issue.id
    issue_url: str | None             # External issue URL (all engines)
    issue_metadata: Dict[str, Any] | None  # Engine-specific data

    # Issue workflow data (engine agnostic)
    should_create_issue: bool | None
    # Engine config and data
    issue_prepare_data: Dict[str, Any] | None
    # Issue creation result from any engine
    issue_result_data: Dict[str, Any] | None

    # User configuration (loaded from Settings)
    prompt_config: Dict[str, Any] | None  # User's prompt configuration
    issue_config: Dict[str, Any] | None   # User's issue configuration

    # Fixed workflow fields
    error_message: str | None
    node_errors: Dict[str, List[NodeError]] | None
    force: bool | None

    # Timestamps
    created_at: str | None
    updated_at: str | None


def create_email_state(
    email_id: str,
    user_id: str,
    force: bool = False
) -> EmailState:
    """
    Create initial EmailState for a new workflow execution.

    Args:
        email_id: Primary identifier for the email message
        user_id: User ID who owns the email
        force: Whether to force processing regardless of current status

    Returns:
        EmailState: Initialized state with default values
    """
    current_time = datetime.utcnow().isoformat()

    return {
        "id": email_id,
        "user_id": user_id,
        "message_id": "",
        "subject": "",
        "sender": "",
        "recipients": "",
        "received_at": "",
        "raw_content": "",
        "html_content": "",
        "text_content": "",
        "attachments": [],
        "summary_title": None,
        "summary_content": None,
        "llm_content": None,
        "metadata": None,
        "issue_id": None,
        "issue_url": None,
        "issue_metadata": None,
        "should_create_issue": False,
        "issue_prepare_data": None,
        "issue_result_data": None,
        "error_message": None,
        "node_errors": {},
        "force": force,
        "created_at": current_time,
        "updated_at": current_time,
    }


def set_global_error(
    state: EmailState,
    error_message: str
) -> EmailState:
    """
    Set global error message.

    Args:
        state: Current email state
        error_message: Error message to set

    Returns:
        EmailState: Updated state with error message
    """
    return {**state, "error_message": error_message}


def clear_global_error(state: EmailState) -> EmailState:
    """
    Clear global error message.

    Args:
        state: Current email state

    Returns:
        EmailState: Updated state without error message
    """
    return {**state, "error_message": None}


def add_node_error(
    state: EmailState,
    node_name: str,
    error_message: str
) -> EmailState:
    """
    Add a node-specific error to the state.

    Args:
        state: Current email state
        node_name: Name of the node that failed
        error_message: Detailed error message

    Returns:
        EmailState: Updated state with new node error
    """
    current_time = datetime.utcnow().isoformat()

    new_error = NodeError(
        error_message=error_message,
        timestamp=current_time
    )

    current_node_errors = state.get("node_errors") or {}
    node_error_list = current_node_errors.get(node_name, [])
    updated_node_error_list = node_error_list + [new_error]

    updated_node_errors = {
        **current_node_errors,
        node_name: updated_node_error_list
    }

    return {**state, "node_errors": updated_node_errors}


def clear_node_errors(state: EmailState) -> EmailState:
    """
    Clear all node-specific errors.

    Args:
        state: Current email state

    Returns:
        EmailState: Updated state without node errors
    """
    return {**state, "node_errors": {}}


def get_node_errors_by_name(
    state: EmailState,
    node_name: str
) -> List[NodeError]:
    """
    Get all errors for a specific node.

    Args:
        state: Current email state
        node_name: Name of the node to get errors for

    Returns:
        List[NodeError]: List of errors for the specified node
    """
    node_errors = state.get("node_errors") or {}
    return node_errors.get(node_name, [])


def has_node_errors(state: EmailState) -> bool:
    """
    Check if there are any node-specific errors.

    Args:
        state: Current email state

    Returns:
        bool: True if there are node errors, False otherwise
    """
    node_errors = state.get("node_errors") or {}
    return len(node_errors) > 0


def clear_node_errors_by_name(
    state: EmailState,
    node_name: str
) -> EmailState:
    """
    Clear errors for a specific node.

    Args:
        state: Current email state
        node_name: Name of the node to clear errors for

    Returns:
        EmailState: Updated state without errors for specified node
    """
    current_node_errors = state.get("node_errors") or {}
    updated_node_errors = {
        key: value for key, value in current_node_errors.items()
        if key != node_name
    }
    return {**state, "node_errors": updated_node_errors}


def get_all_node_names_with_errors(state: EmailState) -> List[str]:
    """
    Get all node names that have errors.

    Args:
        state: Current email state

    Returns:
        List[str]: List of node names that have errors
    """
    node_errors = state.get("node_errors") or {}
    return list(node_errors.keys())
